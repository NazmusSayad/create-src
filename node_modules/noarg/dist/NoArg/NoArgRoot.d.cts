import { NoArgCoreHelper } from "./NoArgCore.cjs";
import { TypeArray } from "../schema/TypeArray.cjs";
import { TypeTuple } from "../schema/TypeTuple.cjs";
import { TypeNumber } from "../schema/TypeNumber.cjs";
import { TypeString } from "../schema/TypeString.cjs";
import { TypeBoolean } from "../schema/TypeBoolean.cjs";
import { TSchemaPrimitive } from "../schema/type.t.cjs";
import { MergeObject, Prettify } from "../types/util.t.cjs";
import { NoArgProgram, NoArgExtract, NoArgProgramHelper } from "./NoArgProgram.cjs";
export declare class NoArgRoot<TName extends string, TSystem extends NoArgCoreHelper.System, TConfig extends NoArgProgramHelper.Config, TOptions extends NoArgCoreHelper.Options> extends NoArgProgram<TName, TSystem, TConfig, TOptions> {
    static colors: {
        disable(): void;
        enable(): void;
    };
    static string<const T extends string[]>(...strings: T): TypeString<T extends [] ? {} : {
        enum: Set<T[number]>;
    }>;
    static number<const T extends number[]>(...numbers: T): TypeNumber<T extends [] ? {} : {
        enum: Set<T[number]>;
    }>;
    static boolean(): TypeBoolean<{}>;
    static array<T extends TSchemaPrimitive>(schema: T): TypeArray<{
        schema: T;
    }>;
    static tuple<T extends TSchemaPrimitive[]>(...schema: T): TypeTuple<{
        schema: TSchemaPrimitive[];
    }>;
    static create<const TName extends string, const TCreateConfig extends NoArgRoot.CreateConfig>(name: TName, { config, system, ...options }: TCreateConfig): NoArgRoot<TName, MergeObject<{
        readonly allowEqualAssign: true;
        readonly allowDuplicateFlagForList: true;
        readonly booleanNotSyntaxEnding: "!";
    }, Required<NonNullable<TCreateConfig["system"]>>> extends infer T extends Record<string, any> ? { [Key in keyof T]: MergeObject<{
        readonly allowEqualAssign: true;
        readonly allowDuplicateFlagForList: true;
        readonly booleanNotSyntaxEnding: "!";
    }, Required<NonNullable<TCreateConfig["system"]>>>[Key]; } : never, MergeObject<{
        readonly help: true;
    }, Required<NonNullable<TCreateConfig["config"]>>> extends infer T_1 extends Record<string, any> ? { [Key_1 in keyof T_1]: MergeObject<{
        readonly help: true;
    }, Required<NonNullable<TCreateConfig["config"]>>>[Key_1]; } : never, Required<MergeObject<{
        readonly arguments: [];
        readonly optionalArguments: [];
        readonly flags: {};
        readonly globalFlags: {};
    }, Omit<TCreateConfig, "config" | "system">>> extends infer T_2 extends Record<string, any> ? { [Key_2 in keyof T_2]: Required<MergeObject<{
        readonly arguments: [];
        readonly optionalArguments: [];
        readonly flags: {};
        readonly globalFlags: {};
    }, Omit<TCreateConfig, "config" | "system">>>[Key_2]; } : never>;
    static defineConfig<const T extends NoArgRoot.CreateConfig>(config: T): Prettify<T>;
    constructor(symbol: symbol, name: TName, system: TSystem, config: TConfig, options: TOptions);
    start(args?: string[]): void;
}
export declare namespace NoArgRoot {
    type CreateConfig = Prettify<Partial<NoArgCoreHelper.Options> & {
        config?: Partial<NoArgCoreHelper.Config>;
        system?: Partial<NoArgCoreHelper.System>;
    }>;
    type InferFlags<T> = T extends NoArgProgram<string, any, any, infer TOptions> ? NoArgExtract.ExtractFlags<TOptions['flags']> : never;
    type InferGlobalFlags<T> = T extends NoArgProgram<string, any, any, infer TOptions> ? NoArgExtract.ExtractFlags<TOptions['globalFlags']> : never;
    type InferCombinedFlags<T> = T extends NoArgProgram<string, any, any, infer TOptions> ? NoArgExtract.ExtractCombinedFlags<TOptions> : never;
    type InferArguments<T> = T extends NoArgProgram<string, any, any, infer TOptions> ? NoArgExtract.ExtractArguments<TOptions['arguments']> : never;
    type InferOptionalArguments<T> = T extends NoArgProgram<string, any, any, infer TOptions> ? NoArgExtract.ExtractOptionalArguments<TOptions['optionalArguments']> : never;
    type InferListArguments<T> = T extends NoArgProgram<string, any, any, infer TOptions> ? undefined extends TOptions['listArgument'] ? never : NoArgExtract.ExtractListArgument<NonNullable<TOptions['listArgument']>> : never;
    type InferCombinedArgs<T> = T extends NoArgProgram<string, any, any, infer TOptions> ? NoArgExtract.ExtractCombinedArgs<TOptions> : never;
}
