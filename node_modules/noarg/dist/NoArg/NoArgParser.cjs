"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoArgParserHelper = exports.NoArgParser = void 0;
const colors_1 = __importDefault(require("../lib/colors.cjs"));
const ask_cli_1 = __importDefault(require("../helpers/ask-cli.cjs"));
const NoArgError_1 = require("./NoArgError.cjs");
const TypeTuple_1 = require("../schema/TypeTuple.cjs");
const TypeArray_1 = require("../schema/TypeArray.cjs");
const TypeBoolean_1 = require("../schema/TypeBoolean.cjs");
const NoArgCore_1 = require("./NoArgCore.cjs");
const split_trailing_args_1 = __importDefault(require("../utils/split-trailing-args.cjs"));
const ThrowExit_1 = __importDefault(require("../helpers/ThrowExit.cjs"));
class NoArgParser extends NoArgCore_1.NoArgCore {
    browsePrograms([name, ...args]) {
        const program = this.programs.get(name);
        if (program) {
            program['startCore'](args);
            return true;
        }
    }
    divideArguments(args) {
        const mainArgs = [];
        const trailingArgs = [];
        if (this.options.trailingArguments) {
            const [main, trailing] = (0, split_trailing_args_1.default)(args, this.options.trailingArguments);
            mainArgs.push(...main);
            trailingArgs.push(...trailing);
        }
        else {
            mainArgs.push(...args);
        }
        let isOptionReached = false;
        const argList = [];
        const options = [];
        for (let arg of mainArgs) {
            const result = this.getFlagMetadata(arg);
            if (!isOptionReached &&
                (result.argType === 'flag' || result.argType === 'alias')) {
                isOptionReached = true;
            }
            if (!isOptionReached) {
                argList.push(arg);
                continue;
            }
            options.push(result);
        }
        return [argList, options, trailingArgs];
    }
    findFlagInSchema(record) {
        const combinedFlags = { ...this.options.globalFlags, ...this.options.flags };
        if (record.argType === 'flag') {
            const schema = combinedFlags[record.key];
            if (schema)
                return { schemaKey: record.key, schema };
        }
        if (record.argType === 'alias') {
            const found = Object.entries(combinedFlags).find(([, schema]) => {
                return schema.config.aliases?.includes(record.key);
            });
            if (found)
                return { schemaKey: found[0], schema: found[1] };
        }
        if (this.system.skipUnknownFlag)
            return;
        throw new NoArgError_1.NoArgError(`Unknown option ${colors_1.default.red(record.arg)} received`);
    }
    getFlagMetadata(rawArg) {
        const isFlag = NoArgParserHelper.flagRegex.test(rawArg);
        const isAlias = NoArgParserHelper.flagAliasRegex.test(rawArg);
        const argType = isFlag
            ? 'flag'
            : isAlias
                ? 'alias'
                : 'value';
        let key = isFlag ? rawArg.slice(2) : isAlias ? rawArg.slice(1) : null;
        let value = null;
        let hasBooleanEndValue;
        if (key) {
            const hasValue = NoArgParserHelper.optionWithValueRegex.test(key);
            if (hasValue) {
                if (!this.system.allowEqualAssign) {
                    throw new NoArgError_1.NoArgError(`Equal assignment is not allowed ${colors_1.default.red(rawArg)}`);
                }
                const { value: _value = null, key: _key = null } = key.match(NoArgParserHelper.optionWithValueRegex)?.groups ?? {};
                key = _key;
                value = _value;
            }
            else if (this.system.booleanNotSyntaxEnding &&
                key.endsWith(this.system.booleanNotSyntaxEnding)) {
                key = key.slice(0, -this.system.booleanNotSyntaxEnding.length);
                hasBooleanEndValue = true;
            }
        }
        else {
            value = rawArg;
        }
        return {
            arg: rawArg,
            key,
            value,
            argType,
            hasBooleanEndValue,
        };
    }
    checkRecordFactory(output) {
        let mustHaveAnyValue = false;
        let prevSchemaKeyRecord = null;
        const handleDuplicateValue = (record, schemaKey) => {
            const outputRecord = output[schemaKey];
            if (outputRecord.schema instanceof TypeArray_1.TypeArray ||
                outputRecord.schema instanceof TypeTuple_1.TypeTuple) {
                if (this.system.allowDuplicateFlagForList) {
                    if (!this.system.overwriteDuplicateFlagForList)
                        return;
                    return (outputRecord.values = []);
                }
            }
            else {
                if (this.system.allowDuplicateFlagForPrimitive) {
                    return (outputRecord.values.length = 0);
                }
            }
            throw new NoArgError_1.NoArgError(`Duplicate option ${colors_1.default.cyan(record.arg)} entered`);
        };
        const handleBooleanEndValue = (record, schema) => {
            if (schema instanceof TypeBoolean_1.TypeBoolean)
                record.value = 'false';
            else {
                throw new NoArgError_1.NoArgError(`Only boolean types accept \`${this.system.booleanNotSyntaxEnding}\` assignment for option: ${colors_1.default.red(record.arg)}`);
            }
        };
        const handleMustHaveValueRecord = () => {
            const outputRecord = output[prevSchemaKeyRecord.schemaKey];
            if (prevSchemaKeyRecord.schema instanceof TypeBoolean_1.TypeBoolean) {
                mustHaveAnyValue = false;
                return outputRecord.values.push('true');
            }
            throw new NoArgError_1.NoArgError(`No value given for option: ${colors_1.default.red(prevSchemaKeyRecord.arg)}`);
        };
        return (record) => {
            if (record.argType === 'flag' || record.argType === 'alias') {
                if (mustHaveAnyValue)
                    handleMustHaveValueRecord();
                const matched = this.findFlagInSchema(record);
                if (!matched)
                    return (prevSchemaKeyRecord = null);
                const { schemaKey, schema } = matched;
                if (schemaKey in output)
                    handleDuplicateValue(record, schemaKey);
                if (record.hasBooleanEndValue)
                    handleBooleanEndValue(record, schema);
                output[schemaKey] ?? (output[schemaKey] = {
                    argType: record.argType,
                    arg: record.arg,
                    schema: schema,
                    values: [],
                });
                if (record.value !== null) {
                    output[schemaKey].values.push(record.value);
                }
                else {
                    mustHaveAnyValue = true;
                }
                return (prevSchemaKeyRecord = { ...record, schemaKey, schema });
            }
            if (record.argType === 'value') {
                if (!prevSchemaKeyRecord) {
                    if (this.system.skipUnknownFlag)
                        return;
                    throw new NoArgError_1.NoArgError(`Unexpected value received: ${colors_1.default.yellow(record.arg)}`);
                }
                mustHaveAnyValue = false;
                return output[prevSchemaKeyRecord.schemaKey].values.push(record.value);
            }
            throw new NoArgError_1.NoArgError(colors_1.default.red('Something went very very wrong, please report this issue'));
        };
    }
    parseFlagsCore(records) {
        if (records.length === 0)
            return {};
        if (records[0].argType === 'value') {
            throw new NoArgError_1.NoArgError(`Received a value: ${colors_1.default.yellow(records[0].arg)}. Expected an option.` +
                '\n But this should never be happened. Please report this issue.');
        }
        const output = {};
        const next = this.checkRecordFactory(output);
        records.forEach(next);
        return output;
    }
    async parseArguments(args) {
        args = [...args];
        const resultArgs = [];
        for (const config of this.options.arguments) {
            const input = args.shift();
            if (!input) {
                if (config.type.config.askQuestion === undefined) {
                    throw new NoArgError_1.NoArgError(`No value provided for argument: ${colors_1.default.blue(config.name)}`);
                }
                const result = await (0, ask_cli_1.default)(config.type, colors_1.default.blue(config.name) + ':');
                resultArgs.push(result);
                continue;
            }
            const { value, error, valid } = config.type.parse(input);
            if (valid) {
                resultArgs.push(value);
                continue;
            }
            throw new NoArgError_1.NoArgError(`${error} for argument: ${colors_1.default.blue(config.name)}`);
        }
        const resultOptArgs = this.options.optionalArguments.map((config) => {
            const input = args.shift();
            if (!input)
                return;
            const { value, error, valid } = config.type.parse(input);
            if (valid)
                return value;
            throw new NoArgError_1.NoArgError(`${error} for argument: ${colors_1.default.blue(config.name)}`);
        });
        const resultListArg = [];
        if (this.options.listArgument) {
            const arraySchema = new TypeArray_1.TypeArray({
                schema: this.options.listArgument.type,
                minLength: this.options.listArgument.minLength,
                maxLength: this.options.listArgument.maxLength,
            });
            const { value, error, valid } = arraySchema.parse(args);
            if (valid) {
                resultListArg.push(...value);
                args.length = 0;
            }
            else {
                throw new NoArgError_1.NoArgError(`${error} for list argument: ${colors_1.default.blue(this.options.listArgument.name)}`);
            }
        }
        if (args.length > 0) {
            throw new NoArgError_1.NoArgError(`Unexpected arguments: ${colors_1.default.green(args.join(' '))}`);
        }
        return {
            resultArgs,
            resultOptArgs,
            resultListArg,
        };
    }
    async parseFlags(records) {
        const flagsRecordWithSchema = this.parseFlagsCore(records);
        const output = {};
        for (const key in flagsRecordWithSchema) {
            const argValue = flagsRecordWithSchema[key];
            if (argValue.values.length === 0) {
                if (argValue.schema instanceof TypeBoolean_1.TypeBoolean) {
                    output[key] = true;
                    continue;
                }
                throw new NoArgError_1.NoArgError(`No value given for option: ${colors_1.default.red(argValue.arg)}`);
            }
            const isList = argValue.schema instanceof TypeArray_1.TypeArray ||
                argValue.schema instanceof TypeTuple_1.TypeTuple;
            if (isList && this.system.splitListByComma) {
                argValue.values = argValue.values.flatMap((value) => value
                    .split(/,/)
                    .map((s) => s.trim())
                    .filter(Boolean));
            }
            if (!isList && argValue.values.length > 1) {
                if (!this.system.allowMultipleValuesForPrimitive) {
                    throw new NoArgError_1.NoArgError(`Multiple value entered \`${argValue.values
                        .map(colors_1.default.green)
                        .join('` `')}\` for option ${colors_1.default.cyan(argValue.arg)}`);
                }
                argValue.values = [argValue.values[argValue.values.length - 1]];
            }
            const { value, error, valid } = argValue.schema.parse(isList ? argValue.values : argValue.values[0]);
            if (!valid) {
                throw new NoArgError_1.NoArgError(`${error} for option: ${colors_1.default.cyan(argValue.arg)}`);
            }
            output[key] = value;
        }
        const combinedFlags = { ...this.options.globalFlags, ...this.options.flags };
        for (const key in combinedFlags) {
            const schema = combinedFlags[key];
            const hasValue = key in output;
            const isRequired = schema.config.required;
            if (!hasValue) {
                if (schema.config.askQuestion !== undefined) {
                    const value = await (0, ask_cli_1.default)(schema, colors_1.default.cyan(`--${key}`) + ':');
                    output[key] = value;
                    continue;
                }
                if ('default' in schema.config) {
                    output[key] = schema.config.default;
                    continue;
                }
                if (isRequired) {
                    throw new NoArgError_1.NoArgError(`Option ${colors_1.default.cyan('--' + key)} is required`);
                }
            }
        }
        return output;
    }
    async parseCore(args) {
        const [argsList, optionsRecord, trailingArgs] = this.divideArguments(args);
        if (this.config.help) {
            const self = this;
            optionsRecord.forEach(({ arg }) => {
                if (arg === '--help' || arg === '-h') {
                    self.renderHelp();
                    throw new ThrowExit_1.default(0);
                }
                if (arg === '--help-usage' || arg === '-hu') {
                    self.renderUsage();
                    throw new ThrowExit_1.default(0);
                }
            });
        }
        const { resultArgs, resultOptArgs, resultListArg } = await this.parseArguments(argsList);
        const resultFlags = await this.parseFlags(optionsRecord);
        return {
            args: resultArgs,
            flags: resultFlags,
            optArgs: resultOptArgs,
            listArgs: resultListArg,
            trailingArgs: trailingArgs,
        };
    }
    parseStart(args) {
        if (this.browsePrograms(args))
            return;
        return this.parseCore(args);
    }
}
exports.NoArgParser = NoArgParser;
var NoArgParserHelper;
(function (NoArgParserHelper) {
    NoArgParserHelper.flagRegex = /^(\-\-)([^\-])/;
    NoArgParserHelper.flagAliasRegex = /^(\-)([^\-])/;
    NoArgParserHelper.optionWithValueRegex = /^(?<key>[^\=]+)\=(?<value>.+)/;
})(NoArgParserHelper || (exports.NoArgParserHelper = NoArgParserHelper = {}));
