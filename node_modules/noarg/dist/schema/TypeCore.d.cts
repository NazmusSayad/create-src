import { ResultErr, ResultOk } from "./result.cjs";
import { MergeObject, Prettify } from "../types/util.t.cjs";
import { ParsedResult, ExtractTypeOutput, InferAndUpdateConfig } from "./type.t.cjs";
export declare class TypeCore<TConfig extends TypeCore.Config> {
    config: TConfig;
    name: string;
    constructor(config: TConfig);
    parse<SELF = typeof this>(value?: string | string[]): ParsedResult<ExtractTypeOutput<SELF>, string>;
    protected checkType(_: unknown): ResultOk | ResultErr;
    default<TDefault extends ExtractTypeOutput<SELF>, SELF = typeof this>(value: TDefault): InferAndUpdateConfig<SELF, Prettify<MergeObject<TConfig, {
        default: TDefault;
        required: true;
    }>>>;
    ask<TDefault extends string, SELF = typeof this>(askQuestion?: TDefault): InferAndUpdateConfig<SELF, Prettify<MergeObject<TConfig, {
        askQuestion: TDefault;
        required: true;
    }>>>;
    aliases<TAliases extends string[], SELF = typeof this>(...aliases: TAliases): InferAndUpdateConfig<SELF, Prettify<MergeObject<TConfig, {
        aliases: TAliases;
    }>>>;
    required<SELF = typeof this>(): InferAndUpdateConfig<SELF, Prettify<MergeObject<TConfig, {
        required: true;
    }>>>;
    description<TDescription extends string, SELF = typeof this>(description: TDescription): InferAndUpdateConfig<SELF, Prettify<MergeObject<TConfig, {
        description: TDescription;
    }>>>;
}
export declare namespace TypeCore {
    type Config = Partial<{
        aliases: string[];
        description: string;
        required: boolean;
        default: any;
        askQuestion: string;
    }>;
    type Sample = TypeCore<Config>;
}
